# Frontend API Integration Guide for Liquor Shop Management System

## Table of Contents
1. [Introduction](#introduction)
2. [HTTP Client Setup](#http-client-setup)
3. [Authentication Integration](#authentication-integration)
4. [API Services Organization](#api-services-organization)
5. [Error Handling Strategies](#error-handling-strategies)
6. [Common API Patterns](#common-api-patterns)
7. [Example Implementations](#example-implementations)
8. [Performance Optimization](#performance-optimization)
9. [Mobile and Responsive Considerations](#mobile-and-responsive-considerations)
10. [Testing API Integration](#testing-api-integration)

## Introduction

This document provides guidelines and examples for frontend developers to effectively integrate with the Liquor Shop Management System backend APIs. It outlines best practices, common patterns, and example implementations to ensure consistency across the application.

### Intended Audience

Frontend developers working on the web or mobile interfaces for the Liquor Shop Management System.

### Technology Stack Assumptions

- **Frontend Framework**: React (web), React Native (mobile)
- **State Management**: Redux Toolkit / Context API
- **HTTP Client**: Axios
- **Type Checking**: TypeScript
- **Form Management**: React Hook Form
- **UI Components**: Material-UI (web), React Native Paper (mobile)

## HTTP Client Setup

### Base Configuration

Create a centralized Axios instance with base configuration:

```typescript
// src/api/axios-client.ts
import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import { store } from '../store';
import { refreshToken, logout } from '../store/auth/auth-slice';

// Create base axios instance
const axiosClient = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL || 'https://api.example.com/api',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  }
});

// Request interceptor for adding auth token
axiosClient.interceptors.request.use(
  (config: AxiosRequestConfig) => {
    const state = store.getState();
    const token = state.auth.token;
    
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
  },
  (error: AxiosError) => {
    return Promise.reject(error);
  }
);

// Response interceptor for handling errors
axiosClient.interceptors.response.use(
  (response: AxiosResponse) => {
    return response;
  },
  async (error: AxiosError) => {
    const originalRequest = error.config;
    
    // Handle token expiration (401 Unauthorized)
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Attempt to refresh the token
        const state = store.getState();
        const refreshTokenValue = state.auth.refreshToken;
        
        if (refreshTokenValue) {
          const result = await store.dispatch(refreshToken(refreshTokenValue)).unwrap();
          
          if (result) {
            // Retry the original request with new token
            originalRequest.headers.Authorization = `Bearer ${result.access_token}`;
            return axiosClient(originalRequest);
          }
        }
        
        // If refresh token is missing or invalid, logout
        store.dispatch(logout());
        return Promise.reject(error);
      } catch (refreshError) {
        // If token refresh fails, logout
        store.dispatch(logout());
        return Promise.reject(refreshError);
      }
    }
    
    // Handle other errors
    return Promise.reject(error);
  }
);

export default axiosClient;
```

### Error Response Structure

All API responses should be in a consistent format:

```typescript
// src/types/api.ts
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  timestamp: string;
}

export interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any[];
  };
  timestamp: string;
}

export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}
```

### API Response Helper Functions

Create helper functions to handle API responses:

```typescript
// src/api/api-helpers.ts
import { AxiosResponse } from 'axios';
import { ApiResponse, PaginatedResponse } from '../types/api';

// Extract data from API response
export function extractData<T>(response: AxiosResponse<ApiResponse<T>>): T {
  return response.data.data as T;
}

// Extract paginated data from API response
export function extractPaginatedData<T>(
  response: AxiosResponse<ApiResponse<PaginatedResponse<T>>>
): PaginatedResponse<T> {
  return response.data.data as PaginatedResponse<T>;
}

// Format error from API response
export function formatApiError(error: any): string {
  if (error.response?.data?.error?.message) {
    return error.response.data.error.message;
  }
  
  if (error.message) {
    return error.message;
  }
  
  return 'An unexpected error occurred. Please try again.';
}
```

## Authentication Integration

### Authentication Service

Create a dedicated service for authentication operations:

```typescript
// src/api/services/auth-service.ts
import axiosClient from '../axios-client';
import { extractData } from '../api-helpers';
import { ApiResponse, User, AuthResult } from '../types';

export const authService = {
  // Login user
  async login(email: string, password: string): Promise<AuthResult> {
    const response = await axiosClient.post<ApiResponse<AuthResult>>('/auth/login', {
      email,
      password
    });
    return extractData(response);
  },
  
  // Refresh token
  async refreshToken(refreshToken: string): Promise<{ access_token: string }> {
    const response = await axiosClient.post<ApiResponse<{ access_token: string }>>('/auth/refresh', {
      refresh_token: refreshToken
    });
    return extractData(response);
  },
  
  // Logout user
  async logout(): Promise<void> {
    await axiosClient.post<ApiResponse<void>>('/auth/logout');
  },
  
  // Get current user
  async getCurrentUser(): Promise<User> {
    const response = await axiosClient.get<ApiResponse<User>>('/users/me');
    return extractData(response);
  },
  
  // Request password reset
  async requestPasswordReset(email: string): Promise<void> {
    await axiosClient.post<ApiResponse<void>>('/auth/password/reset/request', { email });
  },
  
  // Reset password with token
  async resetPassword(token: string, password: string): Promise<void> {
    await axiosClient.post<ApiResponse<void>>('/auth/password/reset/confirm', {
      token,
      password
    });
  },
  
  // Change password
  async changePassword(currentPassword: string, newPassword: string): Promise<void> {
    await axiosClient.post<ApiResponse<void>>('/users/change-password', {
      current_password: currentPassword,
      new_password: newPassword
    });
  }
};
```

### Authentication State Management

Use Redux Toolkit for managing authentication state:

```typescript
// src/store/auth/auth-slice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { authService } from '../../api/services/auth-service';
import { AuthResult, User } from '../../types';

interface AuthState {
  token: string | null;
  refreshToken: string | null;
  user: User | null;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  token: localStorage.getItem('token'),
  refreshToken: localStorage.getItem('refreshToken'),
  user: JSON.parse(localStorage.getItem('user') || 'null'),
  loading: false,
  error: null
};

// Async thunks
export const login = createAsyncThunk(
  'auth/login',
  async ({ email, password }: { email: string; password: string }, { rejectWithValue }) => {
    try {
      return await authService.login(email, password);
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);

export const getCurrentUser = createAsyncThunk(
  'auth/getCurrentUser',
  async (_, { rejectWithValue }) => {
    try {
      return await authService.getCurrentUser();
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);

export const refreshToken = createAsyncThunk(
  'auth/refreshToken',
  async (refreshToken: string, { rejectWithValue }) => {
    try {
      return await authService.refreshToken(refreshToken);
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);

export const logout = createAsyncThunk(
  'auth/logout',
  async (_, { rejectWithValue }) => {
    try {
      await authService.logout();
      return true;
    } catch (error) {
      return rejectWithValue(error);
    }
  }
);

// Auth slice
export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    // Login
    builder.addCase(login.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(login.fulfilled, (state, action: PayloadAction<AuthResult>) => {
      state.loading = false;
      state.token = action.payload.access_token;
      state.refreshToken = action.payload.refresh_token;
      state.user = action.payload.user;
      
      // Save to localStorage
      localStorage.setItem('token', action.payload.access_token);
      localStorage.setItem('refreshToken', action.payload.refresh_token);
      localStorage.setItem('user', JSON.stringify(action.payload.user));
    });
    builder.addCase(login.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload ? String(action.payload) : 'Login failed';
    });
    
    // Get current user
    builder.addCase(getCurrentUser.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(getCurrentUser.fulfilled, (state, action: PayloadAction<User>) => {
      state.loading = false;
      state.user = action.payload;
      localStorage.setItem('user', JSON.stringify(action.payload));
    });
    builder.addCase(getCurrentUser.rejected, (state) => {
      state.loading = false;
      // If getting user fails, clear auth state
      state.token = null;
      state.refreshToken = null;
      state.user = null;
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    });
    
    // Refresh token
    builder.addCase(refreshToken.fulfilled, (state, action) => {
      state.token = action.payload.access_token;
      localStorage.setItem('token', action.payload.access_token);
    });
    
    // Logout
    builder.addCase(logout.fulfilled, (state) => {
      state.token = null;
      state.refreshToken = null;
      state.user = null;
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
    });
  }
});

export const { clearError } = authSlice.actions;
export default authSlice.reducer;
```

### Protected Route Component

Create a component to protect routes requiring authentication:

```tsx
// src/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../store';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: string | string[];
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRole 
}) => {
  const location = useLocation();
  const { token, user } = useSelector((state: RootState) => state.auth);
  
  // If not authenticated, redirect to login
  if (!token || !user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  // If specific role is required, check user role
  if (requiredRole) {
    const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
    if (!roles.includes(user.role)) {
      return <Navigate to="/unauthorized" replace />;
    }
  }
  
  return <>{children}</>;
};

export default ProtectedRoute;
```

## API Services Organization

### Service Pattern

Organize API services by domain:

```typescript
// src/api/services/index.ts
export * from './auth-service';
export * from './user-service';
export * from './shop-service';
export * from './brand-service';
export * from './inventory-service';
export * from './sales-service';
export * from './purchase-service';
export * from './supplier-service';
export * from './reports-service';
// ... and so on
```

### Example Service Implementation

Here's an implementation for the Sales service:

```typescript
// src/api/services/sales-service.ts
import axiosClient from '../axios-client';
import { extractData, extractPaginatedData } from '../api-helpers';
import { 
  ApiResponse, 
  Sale, 
  SaleDetail, 
  CreateSaleRequest, 
  PaginatedResponse 
} from '../types';

export const salesService = {
  // Get all sales
  async getSales(params?: {
    page?: number;
    limit?: number;
    shop_id?: string;
    date?: string;
    status?: string;
    payment_method?: string;
  }): Promise<PaginatedResponse<Sale>> {
    const response = await axiosClient.get<ApiResponse<PaginatedResponse<Sale>>>('/sales', { params });
    return extractPaginatedData(response);
  },
  
  // Get sale by ID
  async getSaleById(id: string): Promise<SaleDetail> {
    const response = await axiosClient.get<ApiResponse<SaleDetail>>(`/sales/${id}`);
    return extractData(response);
  },
  
  // Create sale
  async createSale(data: CreateSaleRequest): Promise<SaleDetail> {
    const response = await axiosClient.post<ApiResponse<SaleDetail>>('/sales', data);
    return extractData(response);
  },
  
  // Approve sale
  async approveSale(id: string, comments: string): Promise<SaleDetail> {
    const response = await axiosClient.post<ApiResponse<SaleDetail>>(`/sales/${id}/approve`, { comments });
    return extractData(response);
  },
  
  // Reject sale
  async rejectSale(id: string, reason: string, comments: string): Promise<SaleDetail> {
    const response = await axiosClient.post<ApiResponse<SaleDetail>>(`/sales/${id}/reject`, { 
      reason, 
      comments 
    });
    return extractData(response);
  },
  
  // Create return
  async createReturn(data: {
    shop_id: string;
    reference_sale_id: string;
    items: Array<{
      brand_id: string;
      quantity: number;
      reason: string;
      condition: string;
    }>;
    refund_method: string;
    comments: string;
  }): Promise<any> {
    const response = await axiosClient.post<ApiResponse<any>>('/returns', data);
    return extractData(response);
  },
  
  // Get dashboard sales metrics
  async getDashboardMetrics(params?: {
    shop_id?: string;
    start_date?: string;
    end_date?: string;
  }): Promise<any> {
    const response = await axiosClient.get<ApiResponse<any>>('/sales/dashboard-metrics', { params });
    return extractData(response);
  }
};
```

### Type Definitions

Define TypeScript interfaces for API data models:

```typescript
// src/types/sales.ts
export interface Sale {
  id: string;
  invoice_number: string;
  shop: {
    id: string;
    name: string;
  };
  created_at: string;
  grand_total: number;
  payment_method: string;
  status: string;
  created_by: {
    id: string;
    name: string;
  };
}

export interface SaleItem {
  brand_id: string;
  brand_name: string;
  quantity: number;
  price_type: string;
  unit_price: number;
  total_price: number;
  tax_amount: number;
  discount_reason?: string;
}

export interface SaleDetail extends Sale {
  items: SaleItem[];
  subtotal: number;
  discount: {
    amount: number;
    reason: string;
  };
  tax_total: number;
  approved_by?: {
    id: string;
    name: string;
  };
  approved_at?: string;
  rejected_by?: {
    id: string;
    name: string;
  };
  rejection_reason?: string;
  rejected_at?: string;
}

export interface CreateSaleRequest {
  shop_id: string;
  items: Array<{
    brand_id: string;
    quantity: number;
    price_type: string;
    price: number;
  }>;
  discount?: {
    amount: number;
    reason: string;
  };
  payment_method: string;
}
```

## Error Handling Strategies

### Global Error Handling

Create a global error handler for consistent error management:

```typescript
// src/utils/error-handler.ts
import { AxiosError } from 'axios';
import { toast } from 'react-toastify';
import { ApiError } from '../types/api';

export const handleApiError = (error: unknown): string => {
  // Handle axios errors
  if (error instanceof AxiosError) {
    // Handle API error response
    if (error.response?.data) {
      const apiError = error.response.data as ApiError;
      
      // Show toast notification for user-friendly error message
      toast.error(apiError.error.message);
      
      // Log detailed error information for debugging
      console.error('API Error:', apiError);
      
      return apiError.error.message;
    }
    
    // Handle network errors
    if (error.request) {
      const message = 'Network error. Please check your connection and try again.';
      toast.error(message);
      console.error('Network Error:', error.message);
      return message;
    }
  }
  
  // Handle generic errors
  const message = error instanceof Error ? error.message : 'An unexpected error occurred';
  toast.error(message);
  console.error('Unexpected Error:', error);
  return message;
};

// Custom error classes
export class ValidationError extends Error {
  errors: Record<string, string[]>;
  
  constructor(message: string, errors: Record<string, string[]>) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

export class AuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthorizationError';
  }
}
```

### Error Boundaries

Implement React Error Boundaries to catch and handle UI rendering errors:

```tsx
// src/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="error-boundary">
          <h2>Something went wrong.</h2>
          <p>Please try refreshing the page or contact support if the problem persists.</p>
          <button onClick={() => window.location.reload()}>
            Refresh Page
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

### Form Validation Error Handling

Use React Hook Form for handling form validation errors:

```tsx
// src/components/forms/SaleForm.tsx
import React from 'react';
import { useForm, useFieldArray, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { TextField, Button, MenuItem, Grid } from '@mui/material';
import { CreateSaleRequest } from '../../types';
import { salesService } from '../../api/services';
import { handleApiError } from '../../utils/error-handler';

// Validation schema
const schema = yup.object().shape({
  shop_id: yup.string().required('Shop is required'),
  items: yup.array().of(
    yup.object().shape({
      brand_id: yup.string().required('Brand is required'),
      quantity: yup.number().required('Quantity is required').positive('Quantity must be positive'),
      price_type: yup.string().required('Price type is required'),
      price: yup.number().required('Price is required').positive('Price must be positive')
    })
  ).min(1, 'At least one item is required'),
  payment_method: yup.string().required('Payment method is required')
});

interface SaleFormProps {
  shops: Array<{ id: string; name: string }>;
  brands: Array<{ id: string; name: string; regular_price: number; discount_price: number }>;
  onSuccess: (sale: any) => void;
}

const SaleForm: React.FC<SaleFormProps> = ({ shops, brands, onSuccess }) => {
  const { control, handleSubmit, watch, setValue, formState: { errors, isSubmitting } } = useForm<CreateSaleRequest>({
    resolver: yupResolver(schema),
    defaultValues: {
      shop_id: '',
      items: [{ brand_id: '', quantity: 1, price_type: 'regular', price: 0 }],
      payment_method: 'cash'
    }
  });
  
  const { fields, append, remove } = useFieldArray({
    control,
    name: 'items'
  });
  
  // Update price when brand or price type changes
  const watchItems = watch('items');
  
  React.useEffect(() => {
    watchItems.forEach((item, index) => {
      if (item.brand_id && item.price_type) {
        const brand = brands.find(b => b.id === item.brand_id);
        if (brand) {
          const price = item.price_type === 'regular' ? brand.regular_price : brand.discount_price;
          setValue(`items.${index}.price`, price);
        }
      }
    });
  }, [watchItems, brands, setValue]);
  
  const onSubmit = async (data: CreateSaleRequest) => {
    try {
      const result = await salesService.createSale(data);
      onSuccess(result);
    } catch (error) {
      handleApiError(error);
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Grid container spacing={3}>
        {/* Shop selection */}
        <Grid item xs={12}>
          <Controller
            name="shop_id"
            control={control}
            render={({ field }) => (
              <TextField
                select
                label="Shop"
                fullWidth
                error={!!errors.shop_id}
                helperText={errors.shop_id?.message}
                {...field}
              >
                {shops.map(shop => (
                  <MenuItem key={shop.id} value={shop.id}>
                    {shop.name}
                  </MenuItem>
                ))}
              </TextField>
            )}
          />
        </Grid>
        
        {/* Items */}
        {fields.map((field, index) => (
          <Grid item xs={12} key={field.id}>
            <Grid container spacing={2}>
              <Grid item xs={4}>
                <Controller
                  name={`items.${index}.brand_id`}
                  control={control}
                  render={({ field }) => (
                    <TextField
                      select
                      label="Product"
                      fullWidth
                      error={!!errors.items?.[index]?.brand_id}
                      helperText={errors.items?.[index]?.brand_id?.message}
                      {...field}
                    >
                      {brands.map(brand => (
                        <MenuItem key={brand.id} value={brand.id}>
                          {brand.name}
                        </MenuItem>
                      ))}
                    </TextField>
                  )}
                />
              </Grid>
              <Grid item xs={2}>
                <Controller
                  name={`items.${index}.quantity`}
                  control={control}
                  render={({ field }) => (
                    <TextField
                      type="number"
                      label="Quantity"
                      fullWidth
                      error={!!errors.items?.[index]?.quantity}
                      helperText={errors.items?.[index]?.quantity?.message}
                      {...field}
                      onChange={e => field.onChange(parseInt(e.target.value, 10) || '')}
                    />
                  )}
                />
              </Grid>
              <Grid item xs={3}>
                <Controller
                  name={`items.${index}.price_type`}
                  control={control}
                  render={({ field }) => (
                    <TextField
                      select
                      label="Price Type"
                      fullWidth
                      error={!!errors.items?.[index]?.price_type}
                      helperText={errors.items?.[index]?.price_type?.message}
                      {...field}
                    >
                      <MenuItem value="regular">Regular</MenuItem>
                      <MenuItem value="discount">Discount</MenuItem>
                    </TextField>
                  )}
                />
              </Grid>
              <Grid item xs={2}>
                <Controller
                  name={`items.${index}.price`}
                  control={control}
                  render={({ field }) => (
                    <TextField
                      type="number"
                      label="Price"
                      fullWidth
                      disabled
                      error={!!errors.items?.[index]?.price}
                      helperText={errors.items?.[index]?.price?.message}
                      {...field}
                      onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                    />
                  )}
                />
              </Grid>
              <Grid item xs={1}>
                <Button 
                  variant="outlined" 
                  color="error" 
                  onClick={() => remove(index)}
                  disabled={fields.length === 1}
                >
                  Remove
                </Button>
              </Grid>
            </Grid>
          </Grid>
        ))}
        
        <Grid item xs={12}>
          <Button
            variant="outlined"
            onClick={() => append({ brand_id: '', quantity: 1, price_type: 'regular', price: 0 })}
          >
            Add Item
          </Button>
        </Grid>
        
        {/* Payment Method */}
        <Grid item xs={12}>
          <Controller
            name="payment_method"
            control={control}
            render={({ field }) => (
              <TextField
                select
                label="Payment Method"
                fullWidth
                error={!!errors.payment_method}
                helperText={errors.payment_method?.message}
                {...field}
              >
                <MenuItem value="cash">Cash</MenuItem>
                <MenuItem value="upi">UPI</MenuItem>
                <MenuItem value="card">Card</MenuItem>
              </TextField>
            )}
          />
        </Grid>
        
        {/* Submit Button */}
        <Grid item xs={12}>
          <Button
            type="submit"
            variant="contained"
            color="primary"
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Processing...' : 'Create Sale'}
          </Button>
        </Grid>
      </Grid>
    </form>
  );
};

export default SaleForm;
```

## Common API Patterns

### CRUD Operations

Create a reusable CRUD hooks for common operations:

```typescript
// src/hooks/use-crud.ts
import { useState, useCallback } from 'react';
import { handleApiError } from '../utils/error-handler';

interface CrudOptions<T, C, U> {
  service: {
    getAll: (params?: any) => Promise<{ items: T[]; pagination: any }>;
    getById: (id: string) => Promise<T>;
    create: (data: C) => Promise<T>;
    update: (id: string, data: U) => Promise<T>;
    delete: (id: string) => Promise<void>;
  };
}

export function useCrud<T, C, U = Partial<C>>({ service }: CrudOptions<T, C, U>) {
  const [items, setItems] = useState<T[]>([]);
  const [currentItem, setCurrentItem] = useState<T | null>(null);
  const [pagination, setPagination] = useState({
    total: 0,
    page: 1,
    limit: 10,
    pages: 0
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Get all items
  const fetchItems = useCallback(async (params?: any) => {
    setLoading(true);
    setError(null);
    try {
      const result = await service.getAll(params);
      setItems(result.items);
      setPagination(result.pagination);
      return result;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [service]);

  // Get item by ID
  const fetchItem = useCallback(async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      const result = await service.getById(id);
      setCurrentItem(result);
      return result;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [service]);

  // Create item
  const createItem = useCallback(async (data: C) => {
    setLoading(true);
    setError(null);
    try {
      const result = await service.create(data);
      setItems(prev => [result, ...prev]);
      return result;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [service]);

  // Update item
  const updateItem = useCallback(async (id: string, data: U) => {
    setLoading(true);
    setError(null);
    try {
      const result = await service.update(id, data);
      setItems(prev => prev.map(item => {
        const itemAny = item as any;
        return itemAny.id === id ? result : item;
      }));
      setCurrentItem(result);
      return result;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      return null;
    } finally {
      setLoading(false);
    }
  }, [service]);

  // Delete item
  const deleteItem = useCallback(async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      await service.delete(id);
      setItems(prev => prev.filter(item => {
        const itemAny = item as any;
        return itemAny.id !== id;
      }));
      if (currentItem && (currentItem as any).id === id) {
        setCurrentItem(null);
      }
      return true;
    } catch (err) {
      const errorMessage = handleApiError(err);
      setError(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, [service, currentItem]);

  return {
    items,
    currentItem,
    pagination,
    loading,
    error,
    fetchItems,
    fetchItem,
    createItem,
    updateItem,
    deleteItem,
    setError
  };
}
```

### Pagination Hook

Create a hook for pagination handling:

```typescript
// src/hooks/use-pagination.ts
import { useState, useCallback } from 'react';

interface PaginationOptions {
  initialPage?: number;
  initialLimit?: number;
}

export function usePagination({ initialPage = 1, initialLimit = 10 }: PaginationOptions = {}) {
  const [page, setPage] = useState(initialPage);
  const [limit, setLimit] = useState(initialLimit);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);

  const updatePagination = useCallback((paginationData: { 
    total: number; 
    page: number; 
    limit: number; 
    pages: number 
  }) => {
    setTotal(paginationData.total);
    setPage(paginationData.page);
    setLimit(paginationData.limit);
    setTotalPages(paginationData.pages);
  }, []);

  const handlePageChange = useCallback((_: React.ChangeEvent<unknown>, newPage: number) => {
    setPage(newPage);
  }, []);

  const handleLimitChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setLimit(parseInt(event.target.value, 10));
    setPage(1); // Reset to first page when changing limit
  }, []);

  const resetPagination = useCallback(() => {
    setPage(initialPage);
    setLimit(initialLimit);
  }, [initialPage, initialLimit]);

  return {
    page,
    limit,
    total,
    totalPages,
    updatePagination,
    handlePageChange,
    handleLimitChange,
    resetPagination,
    paginationParams: { page, limit }
  };
}
```

### File Upload Helper

Create a utility for file uploads:

```typescript
// src/utils/file-upload.ts
import axiosClient from '../api/axios-client';
import { extractData } from '../api/api-helpers';
import { ApiResponse } from '../types/api';

export interface UploadedFile {
  id: string;
  name: string;
  type: string;
  size: number;
  url: string;
  category?: string;
  uploaded_at: string;
}

export async function uploadFile(
  file: File, 
  onProgress?: (progress: number) => void
): Promise<UploadedFile> {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await axiosClient.post<ApiResponse<UploadedFile>>(
    '/files/upload',
    formData,
    {
      headers: {
        'Content-Type': 'multipart/form-data'
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      }
    }
  );
  
  return extractData(response);
}

export async function uploadMultipleFiles(
  files: File[], 
  onTotalProgress?: (progress: number) => void
): Promise<UploadedFile[]> {
  const totalFiles = files.length;
  let completedFiles = 0;
  
  const results = await Promise.all(
    files.map(async (file) => {
      const result = await uploadFile(file, (fileProgress) => {
        // Calculate total progress across all files
        if (onTotalProgress) {
          const individualContribution = fileProgress / 100 / totalFiles;
          const completedContribution = completedFiles / totalFiles;
          const totalProgress = Math.round((completedContribution + individualContribution) * 100);
          onTotalProgress(totalProgress);
        }
      });
      
      completedFiles++;
      return result;
    })
  );
  
  return results;
}
```

## Example Implementations

### Authentication Implementation

```tsx
// src/pages/Login.tsx
import React, { useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { 
  Container, 
  Box, 
  Typography, 
  TextField, 
  Button, 
  Paper,
  Alert
} from '@mui/material';
import { useNavigate, useLocation } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { AppDispatch, RootState } from '../store';
import { login, clearError } from '../store/auth/auth-slice';

// Validation schema
const schema = yup.object().shape({
  email: yup.string().email('Invalid email').required('Email is required'),
  password: yup.string().required('Password is required')
});

interface FormData {
  email: string;
  password: string;
}

const Login: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const location = useLocation();
  const { loading, error } = useSelector((state: RootState) => state.auth);
  const [showPassword, setShowPassword] = useState(false);
  
  // Get the page user was trying to access
  const from = (location.state as any)?.from?.pathname || '/dashboard';
  
  const { control, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: yupResolver(schema),
    defaultValues: {
      email: '',
      password: ''
    }
  });
  
  const onSubmit = async (data: FormData) => {
    try {
      const result = await dispatch(login(data)).unwrap();
      if (result) {
        navigate(from, { replace: true });
      }
    } catch (err) {
      // Error is handled in the slice
    }
  };
  
  return (
    <Container maxWidth="sm">
      <Box mt={8} display="flex" flexDirection="column" alignItems="center">
        <Paper elevation={3} sx={{ padding: 4, width: '100%' }}>
          <Typography component="h1" variant="h5" align="center" gutterBottom>
            Log in to your account
          </Typography>
          
          {error && (
            <Box mt={2} mb={2}>
              <Alert 
                severity="error" 
                onClose={() => dispatch(clearError())}
              >
                {error}
              </Alert>
            </Box>
          )}
          
          <form onSubmit={handleSubmit(onSubmit)} noValidate>
            <Box mb={2}>
              <Controller
                name="email"
                control={control}
                render={({ field }) => (
                  <TextField
                    {...field}
                    label="Email"
                    fullWidth
                    variant="outlined"
                    error={!!errors.email}
                    helperText={errors.email?.message}
                    autoComplete="email"
                    autoFocus
                  />
                )}
              />
            </Box>
            
            <Box mb={3}>
              <Controller
                name="password"
                control={control}
                render={({ field }) => (
                  <TextField
                    {...field}
                    label="Password"
                    fullWidth
                    variant="outlined"
                    type={showPassword ? 'text' : 'password'}
                    error={!!errors.password}
                    helperText={errors.password?.message}
                    autoComplete="current-password"
                  />
                )}
              />
            </Box>
            
            <Button
              type="submit"
              fullWidth
              variant="contained"
              color="primary"
              disabled={loading}
              sx={{ mb: 2 }}
            >
              {loading ? 'Logging in...' : 'Log in'}
            </Button>
            
            <Box display="flex" justifyContent="center">
              <Button
                onClick={() => navigate('/forgot-password')}
                color="primary"
                variant="text"
              >
                Forgot your password?
              </Button>
            </Box>
          </form>
        </Paper>
      </Box>
    </Container>
  );
};

export default Login;
```

### Data List View with Pagination and Filtering

```tsx
// src/pages/Brands.tsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  Box, 
  Button, 
  Card, 
  CardContent, 
  Container, 
  Grid, 
  TextField,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Chip,
  MenuItem,
  InputAdornment,
  Paper
} from '@mui/material';
import { 
  Add as AddIcon, 
  Edit as EditIcon, 
  Delete as DeleteIcon,
  Search as SearchIcon
} from '@mui/icons-material';
import { brandService } from '../api/services';
import { usePagination } from '../hooks/use-pagination';
import { Brand } from '../types';
import DeleteConfirmDialog from '../components/DeleteConfirmDialog';
import { handleApiError } from '../utils/error-handler';
import LoadingScreen from '../components/LoadingScreen';

const Brands: React.FC = () => {
  const navigate = useNavigate();
  const [brands, setBrands] = useState<Brand[]>([]);
  const [loading, setLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('');
  const [statusFilter, setStatusFilter] = useState('');
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [brandToDelete, setBrandToDelete] = useState<Brand | null>(null);
  
  const {
    page,
    limit,
    total,
    totalPages,
    updatePagination,
    handlePageChange,
    handleLimitChange,
    paginationParams
  } = usePagination();
  
  const fetchBrands = async () => {
    setLoading(true);
    try {
      const params = {
        ...paginationParams,
        search: searchTerm || undefined,
        category: categoryFilter || undefined,
        status: statusFilter || undefined
      };
      
      const response = await brandService.getBrands(params);
      setBrands(response.items);
      updatePagination(response.pagination);
    } catch (error) {
      handleApiError(error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchBrands();
  }, [page, limit, searchTerm, categoryFilter, statusFilter]);
  
  const handleDeleteClick = (brand: Brand) => {
    setBrandToDelete(brand);
    setDeleteDialogOpen(true);
  };
  
  const handleDeleteConfirm = async () => {
    if (!brandToDelete) return;
    
    setLoading(true);
    try {
      await brandService.deleteBrand(brandToDelete.id);
      fetchBrands();
    } catch (error) {
      handleApiError(error);
    } finally {
      setLoading(false);
      setDeleteDialogOpen(false);
      setBrandToDelete(null);
    }
  };
  
  return (
    <Container maxWidth="lg">
      <Box my={4}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Typography variant="h4" component="h1">
            Brands
          </Typography>
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={() => navigate('/brands/create')}
          >
            Add Brand
          </Button>
        </Box>
        
        <Card mb={4}>
          <CardContent>
            <Grid container spacing={2} alignItems="center">
              <Grid item xs={12} md={4}>
                <TextField
                  fullWidth
                  label="Search"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <SearchIcon />
                      </InputAdornment>
                    )
                  }}
                />
              </Grid>
              <Grid item xs={12} md={3}>
                <TextField
                  select
                  fullWidth
                  label="Category"
                  value={categoryFilter}
                  onChange={(e) => setCategoryFilter(e.target.value)}
                >
                  <MenuItem value="">All Categories</MenuItem>
                  <MenuItem value="whisky">Whisky</MenuItem>
                  <MenuItem value="vodka">Vodka</MenuItem>
                  <MenuItem value="rum">Rum</MenuItem>
                  <MenuItem value="beer">Beer</MenuItem>
                  <MenuItem value="wine">Wine</MenuItem>
                </TextField>
              </Grid>
              <Grid item xs={12} md={3}>
                <TextField
                  select
                  fullWidth
                  label="Status"
                  value={statusFilter}
                  onChange={(e) => setStatusFilter(e.target.value)}
                >
                  <MenuItem value="">All Statuses</MenuItem>
                  <MenuItem value="active">Active</MenuItem>
                  <MenuItem value="inactive">Inactive</MenuItem>
                </TextField>
              </Grid>
              <Grid item xs={12} md={2}>
                <Button 
                  fullWidth 
                  variant="outlined" 
                  onClick={() => {
                    setSearchTerm('');
                    setCategoryFilter('');
                    setStatusFilter('');
                  }}
                >
                  Clear Filters
                </Button>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
        
        <Paper elevation={2} sx={{ mt: 3 }}>
          {loading ? (
            <LoadingScreen height="400px" />
          ) : (
            <>
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Name</TableCell>
                      <TableCell>Category</TableCell>
                      <TableCell>Size</TableCell>
                      <TableCell align="right">Regular Price</TableCell>
                      <TableCell align="right">Discount Price</TableCell>
                      <TableCell>Status</TableCell>
                      <TableCell align="right">Actions</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {brands.map((brand) => (
                      <TableRow key={brand.id}>
                        <TableCell>{brand.name}</TableCell>
                        <TableCell>{brand.category}</TableCell>
                        <TableCell>{brand.size}</TableCell>
                        <TableCell align="right">₹{brand.regular_price}</TableCell>
                        <TableCell align="right">₹{brand.discount_price}</TableCell>
                        <TableCell>
                          <Chip 
                            label={brand.status} 
                            color={brand.status === 'active' ? 'success' : 'default'} 
                            size="small" 
                          />
                        </TableCell>
                        <TableCell align="right">
                          <IconButton
                            color="primary"
                            onClick={() => navigate(`/brands/${brand.id}`)}
                          >
                            <EditIcon />
                          </IconButton>
                          <IconButton
                            color="error"
                            onClick={() => handleDeleteClick(brand)}
                          >
                            <DeleteIcon />
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
              
              <TablePagination
                rowsPerPageOptions={[10, 25, 50]}
                component="div"
                count={total}
                rowsPerPage={limit}
                page={page - 1}
                onPageChange={(_, page) => handlePageChange(null, page + 1)}
                onRowsPerPageChange={handleLimitChange}
              />
            </>
          )}
        </Paper>
      </Box>
      
      <DeleteConfirmDialog
        open={deleteDialogOpen}
        title="Delete Brand"
        content={`Are you sure you want to delete the brand "${brandToDelete?.name}"? This action cannot be undone.`}
        onConfirm={handleDeleteConfirm}
        onCancel={() => setDeleteDialogOpen(false)}
      />
    </Container>
  );
};

export default Brands;
```

### Dashboard with Multiple API Calls

```tsx
// src/pages/Dashboard.tsx
import React, { useEffect, useState } from 'react';
import { 
  Box, 
  Container, 
  Grid, 
  Paper, 
  Typography, 
  Card, 
  CardContent,
  CardHeader,
  Button,
  MenuItem,
  TextField
} from '@mui/material';
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from 'recharts';
import { dashboardService, shopService } from '../api/services';
import { handleApiError } from '../utils/error-handler';
import LoadingScreen from '../components/LoadingScreen';

const Dashboard: React.FC = () => {
  const [shops, setShops] = useState<Array<{id: string; name: string}>>([]);
  const [selectedShop, setSelectedShop] = useState<string>('all');
  const [timeRange, setTimeRange] = useState<string>('7d');
  const [loading, setLoading] = useState<boolean>(true);
  const [metrics, setMetrics] = useState<any>(null);
  
  // Fetch shops for the dropdown
  useEffect(() => {
    const fetchShops = async () => {
      try {
        const response = await shopService.getShops({ limit: 100 });
        setShops(response.items.map(shop => ({ id: shop.id, name: shop.name })));
      } catch (error) {
        handleApiError(error);
      }
    };
    
    fetchShops();
  }, []);
  
  // Fetch dashboard data
  useEffect(() => {
    const fetchDashboardData = async () => {
      setLoading(true);
      try {
        const shopId = selectedShop === 'all' ? undefined : selectedShop;
        const response = await dashboardService.getDashboardMetrics({
          shop_id: shopId,
          time_range: timeRange
        });
        setMetrics(response);
      } catch (error) {
        handleApiError(error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchDashboardData();
  }, [selectedShop, timeRange]);
  
  if (loading && !metrics) {
    return <LoadingScreen />;
  }
  
  // If data is not loaded yet, return null
  if (!metrics) {
    return null;
  }
  
  // Colors for charts
  const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];
  
  return (
    <Container maxWidth="xl">
      <Box my={4}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Typography variant="h4" component="h1">
            Dashboard
          </Typography>
          
          <Box display="flex" gap={2}>
            <TextField
              select
              label="Time Range"
              value={timeRange}
              onChange={(e) => setTimeRange(e.target.value)}
              sx={{ minWidth: 120 }}
            >
              <MenuItem value="7d">Last 7 Days</MenuItem>
              <MenuItem value="30d">Last 30 Days</MenuItem>
              <MenuItem value="90d">Last 90 Days</MenuItem>
              <MenuItem value="this_month">This Month</MenuItem>
              <MenuItem value="last_month">Last Month</MenuItem>
              <MenuItem value="this_year">This Year</MenuItem>
            </TextField>
            
            <TextField
              select
              label="Shop"
              value={selectedShop}
              onChange={(e) => setSelectedShop(e.target.value)}
              sx={{ minWidth: 200 }}
            >
              <MenuItem value="all">All Shops</MenuItem>
              {shops.map((shop) => (
                <MenuItem key={shop.id} value={shop.id}>
                  {shop.name}
                </MenuItem>
              ))}
            </TextField>
            
            <Button variant="outlined" onClick={() => window.print()}>
              Print Report
            </Button>
          </Box>
        </Box>
        
        {/* KPI Summary Cards */}
        <Grid container spacing={3} mb={4}>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Sales
                </Typography>
                <Typography variant="h4" component="div">
                  ₹{metrics.sales_summary.total_sales.toLocaleString()}
                </Typography>
                <Typography color="textSecondary" sx={{ 
                  color: metrics.sales_summary.growth_percentage >= 0 ? 'green' : 'red' 
                }}>
                  {metrics.sales_summary.growth_percentage >= 0 ? '+' : ''}
                  {metrics.sales_summary.growth_percentage}% vs previous
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Transactions
                </Typography>
                <Typography variant="h4" component="div">
                  {metrics.sales_summary.transactions.toLocaleString()}
                </Typography>
                <Typography color="textSecondary">
                  Avg. ₹{metrics.sales_summary.average_value.toLocaleString()} per transaction
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Profit
                </Typography>
                <Typography variant="h4" component="div">
                  ₹{metrics.financial_summary.profit.toLocaleString()}
                </Typography>
                <Typography color="textSecondary">
                  Margin: {metrics.financial_summary.margin_percentage}%
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Low Stock Items
                </Typography>
                <Typography variant="h4" component="div">
                  {metrics.inventory_summary.low_stock_count}
                </Typography>
                <Typography color="textSecondary">
                  {metrics.inventory_summary.expiring_soon_count} items expiring soon
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
        
        {/* Sales Trend Chart */}
        <Paper elevation={2} sx={{ p: 3, mb: 4 }}>
          <Typography variant="h6" gutterBottom>
            Sales Trend
          </Typography>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={metrics.sales_trend}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line 
                type="monotone" 
                dataKey="amount" 
                stroke="#8884d8" 
                name="Sales Amount" 
              />
              <Line 
                type="monotone" 
                dataKey="transactions" 
                stroke="#82ca9d" 
                name="Transactions" 
              />
            </LineChart>
          </ResponsiveContainer>
        </Paper>
        
        {/* Charts Row */}
        <Grid container spacing={3}>
          {/* Category Sales Chart */}
          <Grid item xs={12} md={6}>
            <Paper elevation={2} sx={{ p: 3, height: '100%' }}>
              <Typography variant="h6" gutterBottom>
                Sales by Category
              </Typography>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={metrics.category_sales}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                    outerRadius={100}
                    fill="#8884d8"
                    dataKey="amount"
                    nameKey="category"
                  >
                    {metrics.category_sales.map((entry: any, index: number) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip formatter={(value) => `₹${value}`} />
                </PieChart>
              </ResponsiveContainer>
            </Paper>
          </Grid>
          
          {/* Top Products Chart */}
          <Grid item xs={12} md={6}>
            <Paper elevation={2} sx={{ p: 3, height: '100%' }}>
              <Typography variant="h6" gutterBottom>
                Top Selling Products
              </Typography>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={metrics.top_products}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="name" />
                  <YAxis />
                  <Tooltip formatter={(value) => `₹${value}`} />
                  <Legend />
                  <Bar dataKey="amount" fill="#8884d8" name="Sales Amount" />
                </BarChart>
              </ResponsiveContainer>
            </Paper>
          </Grid>
          
          {/* Shop Performance */}
          {selectedShop === 'all' && (
            <Grid item xs={12}>
              <Paper elevation={2} sx={{ p: 3 }}>
                <Typography variant="h6" gutterBottom>
                  Shop Performance
                </Typography>
                <ResponsiveContainer width="100%" height={300}>
                  <BarChart data={metrics.shop_performance}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis />
                    <Tooltip formatter={(value) => `₹${value}`} />
                    <Legend />
                    <Bar dataKey="sales" fill="#8884d8" name="Sales Amount" />
                    <Bar dataKey="profit" fill="#82ca9d" name="Profit" />
                  </BarChart>
                </ResponsiveContainer>
              </Paper>
            </Grid>
          )}
        </Grid>
      </Box>
    </Container>
  );
};

export default Dashboard;
```

## Performance Optimization

### API Request Caching

Implement request caching with a custom hook:

```typescript
// src/hooks/use-api-cache.ts
import { useState, useEffect, useCallback } from 'react';

interface CacheOptions {
  cacheTime?: number; // Time in milliseconds to keep cache valid
  staleTime?: number; // Time in milliseconds to consider data stale
}

interface CacheItem<T> {
  data: T;
  timestamp: number;
}

// Simple in-memory cache
const cache: Record<string, CacheItem<any>> = {};

export function useApiCache<T>(
  cacheKey: string,
  fetchFn: () => Promise<T>,
  options: CacheOptions = {}
) {
  const { cacheTime = 5 * 60 * 1000, staleTime = 0 } = options;
  
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Check if cache is stale
  const isStale = useCallback(() => {
    const cachedItem = cache[cacheKey];
    if (!cachedItem) return true;
    
    const now = Date.now();
    return now - cachedItem.timestamp > staleTime;
  }, [cacheKey, staleTime]);
  
  // Fetch data function
  const fetchData = useCallback(async (force = false) => {
    // If data exists in cache and is not stale and not forced, use it
    if (!force && cache[cacheKey] && !isStale()) {
      setData(cache[cacheKey].data);
      return cache[cacheKey].data;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await fetchFn();
      
      // Update cache
      cache[cacheKey] = {
        data: result,
        timestamp: Date.now()
      };
      
      // Schedule cache expiration
      setTimeout(() => {
        delete cache[cacheKey];
      }, cacheTime);
      
      setData(result);
      return result;
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
      throw err;
    } finally {
      setLoading(false);
    }
  }, [cacheKey, cacheTime, fetchFn, isStale]);
  
  // Initial data fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, loading, error, refetch: fetchData };
}
```

### Debounced Search Hook

Create a hook for debounced input:

```typescript
// src/hooks/use-debounce.ts
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  
  return debouncedValue;
}
```

### Optimistic UI Updates

Implement optimistic updates for form submissions:

```typescript
// src/hooks/use-optimistic-update.ts
import { useState, useCallback } from 'react';

interface OptimisticUpdateOptions<T, U> {
  updateFn: (id: string, data: U) => Promise<T>;
  onSuccess?: (result: T) => void;
  onError?: (error: any) => void;
}

export function useOptimisticUpdate<T, U>({ 
  updateFn, 
  onSuccess, 
  onError 
}: OptimisticUpdateOptions<T, U>) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const update = useCallback(async (id: string, data: U, optimisticUpdate: (data: U) => void) => {
    setLoading(true);
    setError(null);
    
    // Apply optimistic update immediately
    optimisticUpdate(data);
    
    try {
      const result = await updateFn(id, data);
      if (onSuccess) {
        onSuccess(result);
      }
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      if (onError) {
        onError(err);
      }
      throw error;
    } finally {
      setLoading(false);
    }
  }, [updateFn, onSuccess, onError]);
  
  return { update, loading, error };
}
```

## Mobile and Responsive Considerations

### Mobile-First Approach

When developing the frontend, use a mobile-first approach:

1. Start designing and implementing for mobile screens first
2. Use responsive design principles with breakpoints for tablet and desktop
3. Utilize media queries effectively
4. Test extensively on different device sizes

### Responsive Components

Ensure all components adapt well to different screen sizes:

```tsx
// src/components/ResponsiveDataTable.tsx
import React from 'react';
import {
  Box,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Card,
  CardContent,
  Typography,
  useMediaQuery,
  useTheme
} from '@mui/material';

interface Column {
  id: string;
  label: string;
  format?: (value: any) => React.ReactNode;
  align?: 'left' | 'right' | 'center';
}

interface ResponsiveDataTableProps {
  columns: Column[];
  data: any[];
  getRowKey: (row: any) => string;
}

const ResponsiveDataTable: React.FC<ResponsiveDataTableProps> = ({
  columns,
  data,
  getRowKey
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  
  // For mobile: render as cards
  if (isMobile) {
    return (
      <Box>
        {data.map((row) => (
          <Card key={getRowKey(row)} sx={{ mb: 2 }}>
            <CardContent>
              {columns.map((column) => (
                <Box key={column.id} sx={{ mb: 1, display: 'flex' }}>
                  <Typography variant="body2" sx={{ fontWeight: 'bold', mr: 1, minWidth: '40%' }}>
                    {column.label}:
                  </Typography>
                  <Typography variant="body2" sx={{ flex: 1 }}>
                    {column.format ? column.format(row[column.id]) : row[column.id]}
                  </Typography>
                </Box>
              ))}
            </CardContent>
          </Card>
        ))}
      </Box>
    );
  }
  
  // For desktop: render as table
  return (
    <TableContainer component={Paper}>
      <Table>
        <TableHead>
          <TableRow>
            {columns.map((column) => (
              <TableCell
                key={column.id}
                align={column.align || 'left'}
              >
                {column.label}
              </TableCell>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((row) => (
            <TableRow key={getRowKey(row)}>
              {columns.map((column) => (
                <TableCell
                  key={column.id}
                  align={column.align || 'left'}
                >
                  {column.format ? column.format(row[column.id]) : row[column.id]}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default ResponsiveDataTable;
```

### Offline Support for Mobile

For mobile app development, implement offline support:

```typescript
// src/api/offline-manager.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface OfflineTransaction {
  id: string;
  type: string;
  data: any;
  timestamp: number;
  status: 'pending' | 'processed' | 'failed';
  error?: string;
}

interface OfflineDB extends DBSchema {
  transactions: {
    key: string;
    value: OfflineTransaction;
    indexes: { 'by-status': string };
  };
  localData: {
    key: string;
    value: any;
  };
}

class OfflineManager {
  private db: Promise<IDBPDatabase<OfflineDB>>;
  
  constructor() {
    this.db = this.initDatabase();
  }
  
  private async initDatabase() {
    return openDB<OfflineDB>('liquor-shop-offline', 1, {
      upgrade(db) {
        const txStore = db.createObjectStore('transactions', { keyPath: 'id' });
        txStore.createIndex('by-status', 'status');
        
        db.createObjectStore('localData', { keyPath: 'key' });
      }
    });
  }
  
  async queueTransaction(type: string, data: any): Promise<string> {
    const id = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const transaction: OfflineTransaction = {
      id,
      type,
      data,
      timestamp: Date.now(),
      status: 'pending'
    };
    
    const db = await this.db;
    await db.add('transactions', transaction);
    return id;
  }
  
  async getQueuedTransactions(): Promise<OfflineTransaction[]> {
    const db = await this.db;
    return db.getAllFromIndex('transactions', 'by-status', 'pending');
  }
  
  async markTransactionProcessed(id: string): Promise<void> {
    const db = await this.db;
    const tx = await db.get('transactions', id);
    if (tx) {
      tx.status = 'processed';
      await db.put('transactions', tx);
    }
  }
  
  async markTransactionFailed(id: string, error: string): Promise<void> {
    const db = await this.db;
    const tx = await db.get('transactions', id);
    if (tx) {
      tx.status = 'failed';
      tx.error = error;
      await db.put('transactions', tx);
    }
  }
  
  async saveLocalData(key: string, data: any): Promise<void> {
    const db = await this.db;
    await db.put('localData', { key, ...data });
  }
  
  async getLocalData(key: string): Promise<any> {
    const db = await this.db;
    return db.get('localData', key);
  }
  
  async clearLocalData(key: string): Promise<void> {
    const db = await this.db;
    await db.delete('localData', key);
  }
}

export const offlineManager = new OfflineManager();
```

## Testing API Integration

### API Mocking with MSW

Setup API mocking with Mock Service Worker:

```typescript
// src/mocks/handlers.ts
import { rest } from 'msw';

export const handlers = [
  // Auth endpoints
  rest.post('/api/auth/login', (req, res, ctx) => {
    const { email, password } = req.body as any;
    
    if (email === 'test@example.com' && password === 'password123') {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          data: {
            access_token: 'mock-token',
            refresh_token: 'mock-refresh-token',
            user: {
              id: 'user-123',
              email: 'test@example.com',
              full_name: 'Test User',
              role: 'manager'
            },
            expires_in: 3600
          },
          timestamp: new Date().toISOString()
        })
      );
    }
    
    return res(
      ctx.status(401),
      ctx.json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password'
        },
        timestamp: new Date().toISOString()
      })
    );
  }),
  
  // Brands endpoint
  rest.get('/api/brands', (req, res, ctx) => {
    const page = Number(req.url.searchParams.get('page')) || 1;
    const limit = Number(req.url.searchParams.get('limit')) || 10;
    
    const mockBrands = Array.from({ length: 25 }, (_, i) => ({
      id: `brand-${i + 1}`,
      name: `Mock Brand ${i + 1}`,
      category: i % 5 === 0 ? 'whisky' : 
              i % 5 === 1 ? 'vodka' : 
              i % 5 === 2 ? 'rum' : 
              i % 5 === 3 ? 'beer' : 'wine',
      size: i % 2 === 0 ? '750ml' : '375ml',
      regular_price: 500 + (i * 50),
      discount_price: 450 + (i * 50),
      status: i % 10 === 0 ? 'inactive' : 'active'
    }));
    
    // Apply pagination
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedBrands = mockBrands.slice(startIndex, endIndex);
    
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: {
          items: paginatedBrands,
          pagination: {
            total: mockBrands.length,
            page,
            limit,
            pages: Math.ceil(mockBrands.length / limit)
          }
        },
        timestamp: new Date().toISOString()
      })
    );
  }),
  
  // Add more mock API handlers as needed
];
```

### React Testing Library Example

Test component that interacts with API:

```typescript
// src/components/__tests__/LoginForm.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import authReducer from '../../store/auth/auth-slice';
import Login from '../../pages/Login';

// Create a mock store
const createMockStore = () => {
  return configureStore({
    reducer: {
      auth: authReducer
    }
  });
};

describe('Login Component', () => {
  it('renders login form correctly', () => {
    render(
      <Provider store={createMockStore()}>
        <BrowserRouter>
          <Login />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByRole('heading', { name: /log in to your account/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /log in/i })).toBeInTheDocument();
  });
  
  it('validates form inputs', async () => {
    render(
      <Provider store={createMockStore()}>
        <BrowserRouter>
          <Login />
        </BrowserRouter>
      </Provider>
    );
    
    // Submit form without entering anything
    fireEvent.click(screen.getByRole('button', { name: /log in/i }));
    
    // Check for validation messages
    expect(await screen.findByText(/email is required/i)).toBeInTheDocument();
    expect(screen.getByText(/password is required/i)).toBeInTheDocument();
    
    // Enter invalid email
    fireEvent.change(screen.getByLabelText(/email/i), { target: { value: 'invalid-email' } });
    
    // Check for email validation
    expect(await screen.findByText(/invalid email/i)).toBeInTheDocument();
  });
  
  it('submits form with valid data', async () => {
    // Mock store with actions tracking
    const store = createMockStore();
    const mockDispatch = jest.fn();
    store.dispatch = mockDispatch;
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <Login />
        </BrowserRouter>
      </Provider>
    );
    
    // Enter valid data
    fireEvent.change(screen.getByLabelText(/email/i), { target: { value: 'test@example.com' } });
    fireEvent.change(screen.getByLabelText(/password/i), { target: { value: 'password123' } });
    
    // Submit form
    fireEvent.click(screen.getByRole('button', { name: /log in/i }));
    
    // Check if login action was dispatched
    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalled();
      const action = mockDispatch.mock.calls[0][0];
      expect(action.type).toBe('auth/login/pending');
    });
  });
});
```

This comprehensive guide provides a solid foundation for frontend developers to connect to the Liquor Shop Management System backend APIs. By following these patterns and examples, you can build a well-structured, maintainable, and performant frontend application that effectively integrates with the backend services.